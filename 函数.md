#函数
函数是R语言中基本的构建模块：掌控着这本书中大多数的先进技术，你应该对函数的工作机理有深刻的认知。你可能已经写过很多函数，或许对它有一定的了解。这章的目的是将你已有的，非正式的函数的认知转化成对函数的严谨的认知。你将会看到在这章中有趣的欺骗和技术，但是大多数还是函数作为基本的模块的重要。
对R的最重要的认知是函数也是对象。你可以像使用其它对象一样使用函数。
#####小测试

1. 函数的三个主要组分是什么？
1. 下面的函数返回的是什么？

   ```{r}
   x <- 10
   f1 <- function(x){
	            function(){
	                 x + 10
	             }
	         }
   f1(1)()                           
   ```
1. 你是否会写下面更加典型的代码？

   ```{r}
   `x`(1,`*`(2,3))
   ```
1. 你如何使下面的代码更加容易阅读？

   ```{r}
   mean(, TRUE, x = c(1:10, NA)) 
   ```
1. 下面的函数在调用的时候是否会抛出一个错误？为什么？

   ```{r}
   f2 <- function(a, b) {
	   a*10
   }
   f2(10, stop("This is an error!"))
   ```
1. 什么是中缀函数？如何写？什么是替代函数？如何写？

1. 你用的什么函数能够确保执行清除行为时，忽视函数是如何终止的？

#####主要内容

* [函数的成分](#function-components)描述函数的主要成分。
* [词法作用域](#lexical-scoping) 教给你如何在绑定空间找到值，作用域的问题
* [函数调用时的行为](#all-calls) 尽管看起来不像，但是所有发生在R中事情都是函数调用的结果。
* [函数变量](#function-arguments) 提供了对函数提供变量的三种方式，给定变量的列表如何调用函数，以及懒估计的结果。
* [特殊调用](#special-calls) 描绘两种函数的特殊类型：中缀函数和取代函数。  
* [Return values](#return-values) 讨论何时，以及如何返回数值，你如何确定在它存在之前做的事情。

#####预备条件
需要使用`pryr`包。

##函数的成分 {#function-components} 
所有的R函数由三个部分组成：

* `body()`,函数的代码部分。
* `formals()`，变量的列表，控制你如何调用函数。
* `environment()`，函数变量的位置。

当你在R中打印函数时，它将会展示这三个部分。如果环境没有被展示出来，说明函数的**创建环境是在全局环境**中。

```{r, eval = FALSE}
f <- function(x) x^2
f
#> function(x) x^2

formals(f)
#> $x
body(f)
#> x^2
environment(f)
#> <environment: R_GlobalEnv>
```
对这三个部分分别进行赋值可以修改这个函数。
就像R中所有的对象，函数可以处理任意多的`attributes()`。一个被base R使用的是“srcref”，是source reference的缩写，指向创建函数的源代码。不像`body()`，它包含了代码的注释和其它的格式。你也可以为函数添加属性。例如，你可以设定`class()`，和`print()`方法。

###原始函数
有一个对于前面所讲的函数规则-有三个组分-的例外。原始函数，像`sum()`，直接使用`.Primitive()`调用C代码，没有R代码。因此它们的`body()`,`formals()`,`environment()`都是`NULL`。

```{r}
sum
formals(sum)
body(sum)
environment(sum)
```

原始函数只在base包里，因为它们在底层，所有更加高效，可以有不同的变量匹配方式。然而，这也导致了它与其它的R的函数有不同的行为。因此，R的核心组避免用它，除非无可避免。
###练习

1. 哪个函数可以用来判别某个对象是不是函数？哪个可以用来判别是不是原始函数？

1.  base包用下面的代码来制定所有函数的列表。

   ```{r}
   objs <- mget(ls("package:base"), inherits = TRUE)
   funs <- Filter(is.function, objs)
   ```
   用它去回答下面的问题：
   a. 哪个基函数有最多的变量？
   
   b. 有多少基函数没有输入变量？这些函数有什么特点？

   c. 你如何修改你代码来得到所有的原始函数？

1. 三个函数的最重要的成分是什么？

1. 什么时候打印函数的时候不会展示它创建的环境？

##词法作用域 {#lexical-scoping}
作用域是R用来查找标志值的一系列规则。在下面的例子中，作用域是用来从`x`中，找到`10`。
```{r}
x <- 10
x
```

了解作用域，你可以：

* 通过组合函数来创建工具。
* 推翻常规的评价规则，创建非标准的评价规则。

R有两个类型的作用域：词法作用域，在语言水平自动执行，是一个动态的作用域，用在交互分析中选择函数来保存类型。我们讨论词法作用域，因为它最初是与函数创建绑定的。
词法的作用域基于当函数创建时是怎么嵌套的查找符号的值，而不是当他们调用时是如何嵌套的。在词法作用域中，你不需要知道函数是如何调用的来判断一个变量的值是怎么查找的。你只需要查看函数的定义。
“词法”并不是常规英语里面的定义，而是来自计算机科学的术语“词法解析”，就是把代码转化成编程语言能理解的有意义的部分。
R的词法作用域的执行后面有四条基本规则：

* 名称掩模
* 函数vs.变量
* 新的起点
* 动态查找

你可能已经知道很多这样的规则，尽管你可能没有真正的考虑过它。在看结果之前，自己跑一下。

###名字掩模
下面的例子解释了词法作用域最基本的使用，你应该可以推测出结果是啥。

```{r, eval = FALSE}
f <- function() {
  x <- 1
  y <- 2
  c(x, y)
}
f()
rm(f)
```

如果名称不在函数内部定义，它会向上一层查找。

```{r, eval = FALSE}
x <- 2
g <- function() {
  y <- 1
  c(x, y)
}
g()
rm(x, g)
```

如果一个函数定义在另一个函数中，这样的规则也适用：在函数中找，然后到函数定义的地方去找，一直到全局环境，然后进入其它加载的包中，在脑中运行下面的程序，然后在R中执行，看看结果。

```{r, eval = FALSE}
x <- 1
h <- function() {
  y <- 2
  i <- function() {
    z <- 3
    c(x, y, z)
  }
  i()
}
h()
rm(x, h)
```

相同的规则适用于闭包函数，也就是在函数中创建的函数。这里我们只看它们与作用域的相互关系。看下面的代码：

```{r, eval = FALSE}
j <- function(x) {
  y <- 2
  function() {
    c(x, y)
  }
}
k <- j(1)
k()
rm(j, k)
```

这个看上去很魔幻。`k`保留了它的定义环境，环境中包含了`y`的值。

###函数 vs. 变量

相同的规则忽略值绑定的数据类型——查找函数和查找变量是相同的。

```{r}
l <- function(x) x + 1
m <- function() {
  l <- function(x) x * 2
  l(10)
}
m()
rm(l, m)
```
对于函数来说，有轻微的调整。如果你在环境中，明显使用了一个函数，R将会自动忽略相同的对象。在下面的例子中，R根据不同的情况查找不同的对象。

```{r}
n <- function(x) x/2
o <- function() {
	n <- 10
	n(n)
}
o()
rm(o,n)
```

然而，函数和其它类型的对象使用相同的名字，容易引起歧义，最好避免这种情况。

###新的起点
在一个函数的唤醒之间，值会发生什么变化？你第一次运行程序会发生什么？第二次呢？
```{r, eval = FALSE}
j <- function() {
  if (!exists("a")) {
    a <- 1
  } else {
    a <- a + 1
  }
  print(a)
}
j()
j()
rm(j)
```

你会很惊讶为什么都是返回的相同的值？这是因为每一次你调用函数的时候，一个新的环境将会被创建。函数不能识别上次做过什么；每一次唤醒都是独立的。

###动态查找
词法作用域决定了哪里去查找值？并没有决定什么时候去查找。R在函数执行的时候进行值查找，并不是创建它的时候。这也决定了函数的结果依赖于环境外的对象。

```{r}
f <- function() x
x <- 15
f()

x <- 20
f()
```

你应该尽量避免这种情况，因为这时函数不是内含的。有一个通常的错误——当你创建函数时，拼写错误不会得到一个错误警告，你在运行的时候也可能得不到，这取决于全局环境中是如何定义的这个变量。

一种检测这种问题的方法是使用`findGlobals()`函数，来自`codetools`。这个函数列出函数所有的外部依赖。
```{r}
f <- function() x + 1
codetools::findGlobals(f)
```
另外一种解决的办法是手动的设定一个空的环境`emptyenv()`，一个绝对不包含任何对象的环境：
```{r}
environment(f) <- emptyenv()
f()
```
这个运行是错误的，因为R依赖于词法作用域去查找所有的东西，包括`+`。不可能完全创建一个内含的函数，因为**依赖于其它的包的函数定义**。

###练习

1. 下面的代码返回什么？为什么？
   
   ```{r}
   c <- 10
   c(c = c)
   ```
1. R查找值的四条规则是什么？

1. 下面的代码返回什么？在执行代码之前，先做一下估计。

  ```{r}
  f <- function(x) { 
    f<- function(x) {
      f <- function(x) {
        x^2
      }
      f(x) + 1
    }
    f(x) *2
  }
f(10)
  ```
## 函数调用时的行为 {#all-calls}

> "To understand computations in R, two slogans are helpful:
>
> * Everything that exists is an object.
> * Everything that happens is a function call."
>
> --- John Chambers

重新定义`(`的前面的例子，可以工作，因为在R中的操作是一次函数的调用，无论看起来像还是不像。这个包含中缀运算符`+`，控制作`for`，`while`，子集运算像`[`,`$`，甚至是`{`。这意味着下面例子中的每一对声明都是等价的。请注意`` ` ``，反引号，可以使你接近保留和非法名字的变量或者函数。

```{r}
x <- 10; y <- 5
x + y
`+`(x, y)

for (i in 1:2) print(i)
`for`(i, 1:2, print(i))

if (i == 1) print("yes!") else print("no.")
`if`(i == 1, print("yes!"), print("no."))

x[3]
`[`(x, 3)

{ print(1); print(2); print(3) }
`{`(print(1), print(2), print(3))
```

当然可以通过这种方式来必定这些函数，但是不是一个主意。然而有一些情况下是很有用的：它允许你做一些之前不可能做的事情。例如，这种特性可以使`dplyr`包将R的表达式，转化成SQL的表达式。[Domain specific languages](#dsl)就是利用了这种观点创建一个域特定的语言，用R存在的结构来精确的表达新的概念。
把特殊的函数看成正常的函数是有用的。例如，我们可以使用`sapply()`通过定义`add()`把3加到列表中的每一个元素。就像下面这样：
```{r}
add <- function(x, y) x + y
sapply(1:10, add, 3)
```
当然我们也可以使用内建的函数`+`来实现：
```{r}
sapply(1:5, `+`, 3)
sapply(1:5, "+", 3)
```
注意`` `+` ``和`` "+" ``之间的区别，前一个是叫做`` `+` ``的对象，后者是一个包含`` "+" ``的字符串。后者可以工作是因为`sapply`可以用函数名来代替函数本身。如果你读`sapply()`的源代码，你将会看到第一行就是`match.fun()`用来找到包含该名字的函数。
一个更加有用的应用是把`sapply()`或者`lapply()`与取子集结合起来：
```{r}
x <- list(1:3, 4:9, 10:12)
sapply(x, "[", 2）

sapply(x, function(x) x[2]
```
R中所发生的事情都有助于你在后面的[metaprogramming](#metaprogramming)。
## 函数变量 {#function-arguments}

识别函数真正的变量和正式的变量是十分有用的。正常的变量是函数的属性，然而真正的变量或者是调用变量在每次调用函数的时候是变化的。这节将讨论如何将调用变量定位到正式变量，如何给定一个列表的变量来调用函数，默认变量是如何工作的，以及lazy赋值的影响。

###调用函数
当调用函数时，你可以按照顺序，完整的名字，或部分名字来指定变量。变量首先与名字相匹配，然后前缀匹配，最后是位置匹配。
```{r, error = TRUE}
f <- function(abcdef, bcde1, bcde2) {
  list(a = abcdef, b1 = bcde1, b2 = bcde2)
}
str(f(1, 2, 3))
str(f(2, 3, abcdef = 1))

# Can abbreviate long argument names:
str(f(2, 3, a = 1))

# But this doesn't work because abbreviation is ambiguous
str(f(1, 3, b = 1))
```
一般情况下，你只需要第一和第二个位置就选出；这是最经常用到的，也是读者可以很容易明白的。避免对不经常使用的变量做位置匹配，在使用部分匹配的时候只使用可以易读的缩写。如果一个函数使用`...`，命名的变量应该紧跟一个未命名的变量。	你只能在`...`的后面用全名指定变量的列表。
下面是很好的调用：
```{r}
mean(1:10)
mean(1:10, trim = 0.05)
```
下面的使用有点过了：
```{r}
mean(x = 1:10)
```
下面的调用是令人困惑的：
```{r}
mean(1:10, n = T)
mean(1:10, FALSE)
mean(1:10, 0.05)
mean(, TRUE, x = c(1:10))
```
###给定一个变量列表来调用函数
假如你有一个函数的参数列表：
```{r}
args <- list(1:10, na.rm = TRUE)
```
那你如何将它传递给`mean()`，这时，你需要`do.call()`:
```{r}
do.call(mean, list(1:10, na.rm = TRUE)
#Equivalent to
mean(1:10, na.rm = TRUE)
```
###默认和丢失的变量
R中的函数变量有默认值：
```{r}
f <- function(a = 1, b = 2){
  c(a, b)
}
f()
```
既然R中的变量是懒洋洋的估计的，默认值可以根据其它变量进行定义。
```{r}
g <- function(a = 1, b = a*2){
  c(a, b)
}
g()
g(10)
```
默认值可以用函数内定义的变量进行定义。这个在base R中经常用到，但是我认为这是一个不好的体验，这是因为如果你不读完全的源文件你不能理解默认值。
```{r}
h <- function(a = 1, b = d){
  d <- (a + 1) ^2
  c(a, b)
}
h()
h(10)
```
你可以用`missing()`判定一个变量是否提供了。
```{r}
i <- function(a, b){
  c(missing(a), missing(b))
}
i()
i(a = 1)
i(b = 2)
i(1, 2)
```
有时候你会添加一个不一般的默认值，这个可能需要好几行的代码来计算。取代在函数定义中插入代码，如果需要的话，你可以使用`missing()`来计算。然而，哪一变量是需要的，哪一个是可选的，不用仔细的读文件，变得很难识别。反而，我通常设置默认值为`NULL`，然后使用`is.null`来判别该变量是否提供了。

###懒evaluation

默认情况下，R函数的变量是懒惰的-他们只会真正用到的时候才进行evaluate：
```{r}
f <- function(x){
  10
}
f(stop("This is an error!"))
```
如果你想要变量被强制evaluate，你可以使用`force()`：
```{r}
f <- function(x){
  force(x)
  10
}
f(stop("This is an error!"))
```
当你想要用`lapply()`或者循环来创建一个闭包函数时，这个会非常有用：
```{r}
add <- function(x){
  function(y) x + y
}

adders <- lapply(1:10, add)
adders[[1]](10)
adders[[10]](10)
```
> 下面部分感觉说错了，可以忽略。

在你第一次调用adder函数时，x是被lazily evaluated。在这点上，循环是完整的，最后`x`的值是10。最后所有的adder函数都10加上它们的输入，这可能不是你想要的。强制转换可能可以解决这个问题。
```{r}
add <- function(x){
  force(x)
  function(y) x + y
}
adders2 <- lapply(1:10, add)
adders2[[1]](10)
adders2[[10]](10)
```
这个代码等价于：
```{r}
add <- function(x){
  x
  function(y) y +x
}
```
这是因为`force <- function(x) x`。然而使用这个函数能够表明你是强制的进行了参数的evaluation。

默认变量是**在函数里面**进行evaluated。这意味着如果表达式依赖于的环境，结果将会根据你是使用默认值不是提供一个而不同。
```{r}
f <- function(x = ls()){
  a <- 1
  x
}

f()
f(ls())
```
更加技术来说，一个unevaluated变量叫做promise。或者是thunk。一个promise是由两个部分组成的：

* 引进延迟计算的表达式。（这个可以使用`substitute()`来访问）
* 表达式创建的环境，以及在何处evaluated。

一个pormise第一次被访问是在创建它的环境中进行evaluated。这个值被缓存起来，所以随后的访问不在计算这个数值。（但是最初的表达式仍然与之相连，可以使用`substitute()`进行访问）。你可以使用`pryr::promise_info()`得到更多的promise的信息。它使用C++代码来在不evaluate它的情况下，得到更多它的信息。这个在R中是不可能实现的。

Laziness在声明中是十分有用的-下面的第二次声明只有在第一次声明为真时才会进行。如果不是，声明将会因为`NULL > 0`是一个长度为0的逻辑向量不能作为`if`的变量而返回一个error。
```{r}
x <- NULL
if(!is.null(x) && x > 0) {
}
```
我们也可以自己执行"&&":
```{r}
`&&` <- function(x, y) {
  if (!x) return(FALSE)
  if (!y) return(FALSE)
  TRUE
}

a <- NULL
!is.null(a) && a > 0
```

如果没有 lazy evaluation，这个函数将不会工作，这是因为`x`和`y`都会被执行，即使`a`是一个`NULL`。
有时，你可以使用laziness一起去估计一个`if`声明。例如：取代下面的代码：
```{r}
if(is.null(a)) stop("a is null")
```
你可以写成：
```{r}
!is.null(a) || stop("a is null")
```
### `...`

R中有一个特殊的参量`...`，这个参量将匹配所有的其它不匹配的参量，并且可以传递到下一个函数。如果你想收集一些参量去调用其它的函数，但是你不想预先定义它们的名字，这个是十分有用的。`...`经常用在S3类的泛型函数使得单个方法更加灵活。
一个相对复杂的`...`的使用者是`plot()`函数。`plot()`是一个参数为`x`,`y`,`...`的函数。为了了解`...`在里面的作用，我们需要阅读帮助文件，“像图形参数，参量可以传递缎带方法”。`plot()`最简单的invocation是最后调用`plot.default()`，这个函数也有很多变量，当然也有`...`。再次，读文件揭示了`...`可以接受图形参量，这些参量列在`par()`中。这个允许我们按照下面写代码：
```{r}
plot(1:5, col = "red")
plot(1:5, cex = 5, pch = 20)
```

这个阐释了`...`参数的好处和劣处。它使得`plot()`特别灵活，但是需要明白如何使用它。我们不得不仔细的阅读文档。此外，如果我们阅读`plot.default`的源代码，我们会发现未被记录的特性。也可以传递其它的变量给`Axis()`和`box()`。
```{r}
plot(1:5, bty = "u")
plot(1:5, labels = FALSE)
```

为了掌握一种更加简单的使用`...`方式，你可以使用`list(...)`。
```{r}
f <- function(...){
  names(list(...))
}
f(a = 1, b = 2)
```

使用`...`是有价值的，任何拼错的变量名字不会产生错误。任何在`...`使用的变量必须是全名的。这使得拼写更不易请注意到。
```{r}
sum(1, 2, NA, na.mr = TRUE)
```
显式比隐式更好的。在有许多额外的函数时，使用`...`是更加简单的。不需要要求使用者去提供额外变量的列表。

####练习

1. 理清奇异函数调用的参数列表：

   ```{r}
   x <- sample(replace = TRUE, 20, x = c(1:10, NA))
   y <- runif(min = 0, max = 1, 20)
   cor(m = "k", y = y, u = "p", x = x)
   ```
1. 下面的函数返回的是什么，为什么？它解释是是什么原理。

   ```{r}
   f1 <- function(x = {y <- 1:2}, y = 0){
     x + y
   }
   f1()
   ```
1. 下面的函数返回什么？为什么？怎么解释？

   ```{r}
   f2 <- function(x = z){
     z <- 100
     x
   }
   f2()
   ```
## 特殊调用 {#special-calls}   
R支持两种调用特殊函数-中缀和替换函数-的语法。

###中缀函数
R中大多数函数是前缀操作符：函数的名字在参数的前面。你也可以创建一个中缀函数，变量的名字出现在函数名字的两侧。像`+`或者`-`。所有的用户自己定义的中缀函数必须夹在`%`之间，下面R中的中缀表达式是预定义的`%%`, `%*%`, `%/%`, `%in%`, `%o%`,  `%x%`。
当然你可以创建一个字符串拼接的函数的新的操作符：
```{r}
`%+%` <- function(a, b) paste0(a, b)
"new" %+% "string"
```
注意，当创建一个函数时，你不得不把名字放置到反引号中，这是因为它是一个特殊的名字。这对于一个通常的函数调用只是一个syntactic sugar；R对于下面两种表达式没有区别：
```{r}
"new" %+% "string"
`%+%`("new", "string")
```
甚至是：
```{r}
1 + 5
`+`(1, 5)
```

中缀函数的名字相对于通常的函数来说更加灵活：它们可以包含任意的字符序列。你需要在创建它们的时候尽量避免过于特殊的字符，但是在调用它们的时候就没有必要了。
```{r}
`% %` <- function(a, b) paste(a, b)
`%'%` <- function(a, b) paste(a, b)
`%/\\%` <- function(a, b) paste(a, b)

"a" % % "b"
"a" %'% "b"
"a" %/\% "b"
```
R的优先规则标定了中缀表达式是从左到右的。
```{r}
`%-%` <- function(a, b) paste0("(", a, " %-% ", b, ")")
"a" %-% "b" %-% "c"
```
有一个我经常使用的中缀函数，灵感来自于Ruby的或运算符。这个与Ruby还是有一些不同，因为Ruby在使用`TURE`的定义上更加灵活。在函数输出为`NULL`时，作为一个默认值是十分有用的方式。
```{r}
`%||%` <- function(a, b) if (!is.null(a)) a else b
function_that_might_return_null() %||% default value
```

###替代函数
替代函数的行为像是在本地进行参数的调整，并且有非常特殊的名字`xx <-`。典型的这种函数有两个参数（`x`和`value`），尽管，它们可以有更多的参数，但是必须返回一个修改的对象。例如，下面的函数允许你修改向量的第二个数值：
```{r}
`second<-` <- function(x, value) {
  x[2] <- value
  x
}
x <- 1:10
second(x) <- 5L
x
```
当函数在估计这个`second(x)<- 5`这个赋值时，注意到`<-`左手边不是一个一般的名字，于是查找`second<-`来进行代替。

我们说它的行为“像”一个在本地进行对象的修改，因为它其实是生成了一个副本。我们可以使用`pryr::address()`来找到对象的内存位置。
```{r, message = FALSE}
library(pryr)
x <- 1:10
address(x)
second(x) <- 6L
address(x)
```
使用内建的`.Primitive()`则是在本地进行对象的修改：
```{r}
x <- 1:10
address(x)
#> [1] "0x103945110"

x[2] <- 7L
address(x)
#> [1] "0x103945110"
```
因为它有很重要的执行涵义，所有了解它的行为是十分重要的。
如果你想提供额外的变量，必须放置在`x`和`value`之间：
```{r}
`modify<-` <- function(x, position, value) {
  x[position] <- value
  x
}
modify(x, 1) <- 10
x
```
当你调用`modify(x, 1) <- 10`时，如下：
```{r}
x <- `modify<-`(x, 1, 10)
```
这意味着你不能这么做：
```{r}
modify(get("x"), 1) <- 10
```
因为这将是一个不合法的语法：
```{r}
get("x") <- `modify<-`(x, 1, 10)
```
把替换和取子集结合起来是十分有用的：
```{r}
x <- c(a = 1, b = 2, c = 3)
names(x)
names(x)[2] <- "two"
names(x)
```
这个可以实现正如你之前所写的：
```{r, eval = FALSE}
`*tmp*` <- names(x)
`*tmp*`[2] <- "two"
names(x) <- `*tmp*`
```

###练习
1. 创建一个base包中的所有的替代函数的列表，哪一个primitive函数。

1. 用户创建的中缀函数的真实名字是什么？

1. 创建一个`xor()`的中缀表达式。

1. 创建一个集合函数`intersect()`, `union()`,`setdiff()`的中缀表达形式。

1. 创建一个可以修改向量随机位置的替换函数。
## 返回值 {#return-values}
函数最后一个表达式的值是函数的返回值，是函数调用的结果：
```{r}
f <- function(x) {
  if (x < 10) {
    0
  } else {
    10
  }
}
f(5)
f(15)
```
一般情况下，保留`return()`是比较好的样式，因为可以减少缩进水平，便于理解。
```{r}
f <- function(x, y) {
  if (!x) return(y)

  # complicated processing here
}
```
函数只能返回一个对象，但是你可以通过返回一个列表，返回任意多的对象。
最容易理解的找出原因的函数是纯函数：相同的输入和输出的对应，对环境没有任何的影响。换句话说，纯函数没有副作用：他们除了返回值对于世界没有任何的影响。
R可以保证你不会发生一类副作用：所有的R对象都是基于复制进行修改的语法。所以修改一个变量不会改变原始的值：
```{r}
f <- function(x) {
  x$a <- 2
  x
}
x <- list(a = 1)
f(x)
x$a
```
（环境和参考类是例外，所以要特别的小心）

这个与java语言有着显著的不同，它们可以修改函数的输入。
大多数据base R的函数是纯的，当然也有一些例外：

* `library()`加载包，所以会修改搜索路径。
* `setwd()`， `Sys.setenv()`,`Sys.setlocale()`分别改变工作路径，环境变量，和本地化。
* `plot()`产生图像输出
* `write()`, `write.csv()`, `saveRDS()`输出到硬盘。
* `options()`和`par()`修改全局设置
* S4相关函数修改，类的全局表和方法
* 随机数生成器，每次产生不同的数值。

减少副作用是一个很好的主意，通过将不纯的函数转化成纯的函数可以减少副作用的痕迹。纯函数很容易去测试，在不同的版本和不同的平台会有很大的不同。例如，ggplot2的激发原则之一，所有在对象上的操作只是代表了一个图，只有最后都会生成一个图像的输出。

函数可以返回一个不可见的数值，当你调用这个函数时，将不会打印这个数值。
```{r}
f1 <- function() 1
f2 <- function() invisible(1)

f1()
f2()
f1() == 1
f2() == 1
```

当然你可以通过将函数放置到圆括号中来强制进行数值的打印。
```{r}
(f2())
```
最通用的返回不可见的函数是`<-`。
```{r}
a <- 2
(a <- 2)
```
这也是为什么可以同时给多个变量进行赋值的原因：
```{r}
a <- b <- c <- d <- 2
```
因为这个可以解释成：
```{r}
(a <- (b <- (c <- (d <- 2))))
```

### On exit
当函数返回数值的同时，函数会触发一些其它的事情，当函数结束时使用`on.exit()`。这个通常用来当函数退出时，保证全局状态被保存的一种方式。`on.exit()`的代码的运行忽视函数的退出，无论是显示退出，不是错误，或者是简单的到达函数的体的结尾。
```{r}
in_dir <- function(dir, code) {
  old <- setwd(dir)
  on.exit(setwd(old))

  force(code)
}
getwd()
in_dir("~", getwd())
```
基本模式很简单：

* 设定一个新的位置的目录，然后通过`setwd()`的输出得到当前的目录。
* 然后使用`on.exit()`确保返回原先的目录。
* 最后显示的执行代码

###练习

1. `source()`中的`chdir`参数与`in_dir()`相比下如何？

1. 哪个函数抵消`library()`的行为？我们如何保存的存储`options()`和`par()`的值？

1. 写一个打开图形设备的函数，执行提供的代码，然后关闭图形设备。

1. 我们可以使用`on.exit()`来执行`capture.output()`的简单版本。

    ```{r}
    capture.output2 <- function(code) {
      temp <- tempfile()
      on.exit(file.remove(temp), add = TRUE)

      sink(temp)
      on.exit(sink(), add = TRUE)

      force(code)
      readLines(temp)
    }
    capture.output2(cat("a", "b", "c", sep = "\n"))
   ```
   对比`capture.output()`和`capture.output2()`。两个函数有什么不同？我移除了什么特性来更容易看到关键观点。我如何重写来使得关键主意理容易理解。
